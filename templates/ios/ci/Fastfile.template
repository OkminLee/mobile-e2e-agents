# Fastfile for E2E UI Tests
# Generated by mobile-e2e-agents

default_platform(:ios)

platform :ios do

  # ================================
  # UI Tests
  # ================================

  desc "Run UI Tests"
  lane :ui_tests do |options|
    # Options
    test_target = options[:test_target] || "{{TEST_TARGET}}"
    device = options[:device] || "iPhone 16 Pro"
    parallel = options[:parallel] || false
    workers = (options[:workers] || 2).to_i
    output_dir = options[:output_directory] || "./test_results"

    UI.message("Running UI Tests")
    UI.message("  Target: #{test_target}")
    UI.message("  Device: #{device}")
    UI.message("  Parallel: #{parallel} (#{workers} workers)")

    # Prepare output directory
    FileUtils.mkdir_p(output_dir)

    # Build xcargs for parallel testing
    xcargs = ""
    if parallel && workers > 0
      xcargs = [
        "-parallel-testing-enabled YES",
        "-parallel-testing-worker-count #{workers}",
        "-retry-tests-on-failure"
      ].join(" ")
      UI.message("  Parallel args: #{xcargs}")
    end

    begin
      scan(
        workspace: "{{WORKSPACE}}.xcworkspace",
        scheme: "{{SCHEME}}",
        devices: [device],
        only_testing: [test_target],
        result_bundle: true,
        output_directory: output_dir,
        xcargs: xcargs,
        fail_build: true,
        clean: false,
        code_coverage: false
      )

      UI.success("UI Tests passed!")

    rescue => e
      UI.error("UI Tests failed: #{e.message}")

      # Collect failure screenshots
      collect_failure_screenshots(output_dir)

      raise e

    ensure
      # Generate report if results exist
      xcresult_path = File.join(output_dir, "*.xcresult")
      xcresult_files = Dir.glob(xcresult_path)

      if xcresult_files.any?
        UI.message("Test results: #{xcresult_files.first}")
        parse_test_results(xcresult_files.first)
      end
    end
  end

  # ================================
  # Helper Methods
  # ================================

  desc "Parse test results from xcresult"
  private_lane :parse_test_results do |xcresult_path|
    UI.message("Parsing test results from: #{xcresult_path}")

    # Get test summary
    summary_json = `xcrun xcresulttool get test-results summary --path "#{xcresult_path}" --format json 2>/dev/null`

    if $?.success? && !summary_json.empty?
      begin
        summary = JSON.parse(summary_json)

        passed = summary["passedTests"] || 0
        failed = summary["failedTests"] || 0
        skipped = summary["skippedTests"] || 0

        UI.message("Test Results:")
        UI.message("  ✅ Passed: #{passed}")
        UI.message("  ❌ Failed: #{failed}")
        UI.message("  ⏭️ Skipped: #{skipped}")

        # Set environment variables for CI
        ENV["TEST_PASSED"] = passed.to_s
        ENV["TEST_FAILED"] = failed.to_s
        ENV["TEST_SKIPPED"] = skipped.to_s

      rescue JSON::ParserError => e
        UI.warning("Failed to parse test summary: #{e.message}")
      end
    else
      UI.warning("Could not get test summary from xcresult")
    end
  end

  desc "Collect screenshots from failed tests"
  private_lane :collect_failure_screenshots do |output_dir|
    screenshots_dir = File.join(output_dir, "failure_screenshots")
    FileUtils.mkdir_p(screenshots_dir)

    # Find xcresult
    xcresult_path = Dir.glob(File.join(output_dir, "*.xcresult")).first
    return unless xcresult_path

    UI.message("Extracting failure screenshots from: #{xcresult_path}")

    # Export attachments using xcresulttool
    export_dir = File.join(output_dir, "attachments")
    system("xcrun xcresulttool export attachments --path '#{xcresult_path}' --output-path '#{export_dir}' 2>/dev/null")

    # Copy image files
    if Dir.exist?(export_dir)
      image_files = Dir.glob(File.join(export_dir, "**/*.{png,jpg,jpeg}"))
      image_files.each do |img|
        FileUtils.cp(img, screenshots_dir)
      end
      UI.message("Collected #{image_files.count} screenshots")
    end
  end

  # ================================
  # Utility Lanes
  # ================================

  desc "Find available simulator"
  private_lane :find_simulator do |options|
    device_name = options[:device] || "iPhone 16 Pro"

    # List available simulators
    simulators = `xcrun simctl list devices available -j`
    data = JSON.parse(simulators)

    # Find matching device
    data["devices"].each do |runtime, devices|
      next unless runtime.include?("iOS")

      devices.each do |device|
        if device["name"] == device_name && device["isAvailable"]
          UI.success("Found simulator: #{device['name']} (#{device['udid']})")
          return device["udid"]
        end
      end
    end

    UI.user_error!("Simulator not found: #{device_name}")
  end

end
