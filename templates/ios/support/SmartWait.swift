//
//  SmartWait.swift
//  {{PROJECT_NAME}}UITests
//
//  Intelligent waiting utilities for E2E tests
//  Generated by mobile-e2e-agents
//

import XCTest

/// Smart waiting utilities that adapt to app state
///
/// Usage:
/// ```swift
/// // Wait for loading to complete
/// SmartWait.forLoadingToComplete(in: app)
///
/// // Wait for network activity to settle
/// SmartWait.forNetworkIdle(in: app)
///
/// // Wait with custom condition
/// SmartWait.until(timeout: 10) {
///     return page.isDataLoaded
/// }
/// ```
enum SmartWait {

    // MARK: - Condition-Based Waiting

    /// Wait until condition is met
    /// - Parameters:
    ///   - timeout: Maximum time to wait
    ///   - interval: Polling interval
    ///   - description: Description for debugging
    ///   - condition: Condition to check
    /// - Returns: true if condition met within timeout
    @discardableResult
    static func until(
        timeout: TimeInterval = Timeout.medium,
        interval: TimeInterval = 0.1,
        description: String = "condition",
        condition: () -> Bool
    ) -> Bool {
        let deadline = Date().addingTimeInterval(timeout)

        while Date() < deadline {
            if condition() {
                return true
            }
            Thread.sleep(forTimeInterval: interval)
        }

        print("[SmartWait] Timeout waiting for: \(description)")
        return false
    }

    /// Wait until condition is met with throwing support
    /// - Parameters:
    ///   - timeout: Maximum time to wait
    ///   - description: Description for error message
    ///   - condition: Condition to check
    static func untilOrFail(
        timeout: TimeInterval = Timeout.medium,
        description: String,
        condition: () -> Bool
    ) {
        let result = until(timeout: timeout, description: description, condition: condition)
        XCTAssertTrue(result, "Timeout waiting for: \(description)")
    }

    // MARK: - Loading States

    /// Wait for loading indicators to disappear
    /// - Parameters:
    ///   - app: Application instance
    ///   - timeout: Maximum time to wait
    /// - Returns: true if loading completed
    @discardableResult
    static func forLoadingToComplete(
        in app: XCUIApplication,
        timeout: TimeInterval = Timeout.long
    ) -> Bool {
        // Common loading indicator identifiers
        let loadingIndicators = [
            app.activityIndicators.firstMatch,
            app.otherElements["loadingIndicator"],
            app.otherElements["activityIndicator"],
            app.staticTexts["Loading..."],
            app.staticTexts["로딩 중..."]
        ]

        return until(timeout: timeout, description: "loading to complete") {
            for indicator in loadingIndicators {
                if indicator.exists && indicator.isHittable {
                    return false
                }
            }
            return true
        }
    }

    /// Wait for any element matching predicate to appear
    /// - Parameters:
    ///   - app: Application instance
    ///   - predicate: NSPredicate to match
    ///   - timeout: Maximum time to wait
    /// - Returns: First matching element, or nil if timeout
    static func forElement(
        in app: XCUIApplication,
        matching predicate: NSPredicate,
        timeout: TimeInterval = Timeout.medium
    ) -> XCUIElement? {
        let elements = app.descendants(matching: .any).matching(predicate)

        let found = until(timeout: timeout, description: "element matching predicate") {
            elements.count > 0 && elements.firstMatch.exists
        }

        return found ? elements.firstMatch : nil
    }

    /// Wait for element with identifier to appear
    /// - Parameters:
    ///   - app: Application instance
    ///   - identifier: Accessibility identifier
    ///   - timeout: Maximum time to wait
    /// - Returns: Element if found, nil if timeout
    static func forElement(
        in app: XCUIApplication,
        withIdentifier identifier: String,
        timeout: TimeInterval = Timeout.medium
    ) -> XCUIElement? {
        let element = app.descendants(matching: .any)[identifier]

        if element.waitForExistence(timeout: timeout) {
            return element
        }

        return nil
    }

    // MARK: - Screen Transitions

    /// Wait for screen transition to complete
    /// - Parameters:
    ///   - from: Source screen identifier (optional)
    ///   - to: Destination screen identifier
    ///   - app: Application instance
    ///   - timeout: Maximum time to wait
    /// - Returns: true if transition completed
    @discardableResult
    static func forScreenTransition(
        from sourceId: String? = nil,
        to destinationId: String,
        in app: XCUIApplication,
        timeout: TimeInterval = Timeout.medium
    ) -> Bool {
        let destination = app.otherElements[destinationId]

        // If source is specified, wait for it to disappear first
        if let sourceId = sourceId {
            let source = app.otherElements[sourceId]
            _ = source.waitToDisappear(timeout: timeout / 2)
        }

        return destination.waitForExistence(timeout: timeout)
    }

    // MARK: - Animation Waiting

    /// Wait for animations to complete (heuristic-based)
    /// - Parameter duration: Time to wait
    static func forAnimations(duration: TimeInterval = 0.5) {
        Thread.sleep(forTimeInterval: duration)
    }

    /// Wait for keyboard to appear
    /// - Parameters:
    ///   - app: Application instance
    ///   - timeout: Maximum time to wait
    /// - Returns: true if keyboard appeared
    @discardableResult
    static func forKeyboard(
        in app: XCUIApplication,
        timeout: TimeInterval = Timeout.short
    ) -> Bool {
        let keyboard = app.keyboards.firstMatch
        return keyboard.waitForExistence(timeout: timeout)
    }

    /// Wait for keyboard to dismiss
    /// - Parameters:
    ///   - app: Application instance
    ///   - timeout: Maximum time to wait
    /// - Returns: true if keyboard dismissed
    @discardableResult
    static func forKeyboardDismiss(
        in app: XCUIApplication,
        timeout: TimeInterval = Timeout.short
    ) -> Bool {
        let keyboard = app.keyboards.firstMatch
        return keyboard.waitToDisappear(timeout: timeout)
    }

    // MARK: - Alert Handling

    /// Wait for system alert to appear
    /// - Parameters:
    ///   - app: Application instance
    ///   - timeout: Maximum time to wait
    /// - Returns: Alert element if found
    static func forSystemAlert(
        in app: XCUIApplication,
        timeout: TimeInterval = Timeout.short
    ) -> XCUIElement? {
        let springboard = XCUIApplication(bundleIdentifier: "com.apple.springboard")
        let alert = springboard.alerts.firstMatch

        if alert.waitForExistence(timeout: timeout) {
            return alert
        }

        return nil
    }

    /// Handle system alert by tapping button with label
    /// - Parameters:
    ///   - app: Application instance
    ///   - buttonLabel: Button label to tap
    ///   - timeout: Maximum time to wait
    /// - Returns: true if alert was handled
    @discardableResult
    static func handleSystemAlert(
        in app: XCUIApplication,
        tappingButton buttonLabel: String,
        timeout: TimeInterval = Timeout.short
    ) -> Bool {
        guard let alert = forSystemAlert(in: app, timeout: timeout) else {
            return false
        }

        let button = alert.buttons[buttonLabel]
        if button.waitForExistence(timeout: 1) {
            button.tap()
            return true
        }

        return false
    }
}
