//
//  XCUIElement+Scroll.swift
//  {{PROJECT_NAME}}UITests
//
//  XCUIElement extensions for scrolling operations
//  Generated by mobile-e2e-agents
//

import XCTest

extension XCUIElement {

    // MARK: - Scroll Into View

    /// Scroll until this element becomes visible and hittable
    /// - Parameters:
    ///   - scrollView: The scroll view to scroll in (defaults to app's first scrollView)
    ///   - direction: Scroll direction
    ///   - maxScrolls: Maximum number of scroll attempts
    /// - Returns: true if element became visible
    @discardableResult
    func scrollIntoView(
        in scrollView: XCUIElement? = nil,
        direction: ScrollDirection = .down,
        maxScrolls: Int = 10
    ) -> Bool {
        let app = XCUIApplication()
        let container = scrollView ?? app.scrollViews.firstMatch

        guard container.exists else {
            return exists && isHittable
        }

        for _ in 0..<maxScrolls {
            if exists && isHittable {
                return true
            }

            switch direction {
            case .up:
                container.swipeDown()
            case .down:
                container.swipeUp()
            case .left:
                container.swipeRight()
            case .right:
                container.swipeLeft()
            }

            // Brief pause for scroll animation
            Thread.sleep(forTimeInterval: 0.3)
        }

        return exists && isHittable
    }

    // MARK: - Scroll Operations

    /// Scroll to top of scroll view
    /// - Parameter maxScrolls: Maximum number of scroll attempts
    @discardableResult
    func scrollToTop(maxScrolls: Int = 10) -> Self {
        guard exists else { return self }

        for _ in 0..<maxScrolls {
            let beforeY = frame.minY
            swipeDown()
            Thread.sleep(forTimeInterval: 0.2)
            let afterY = frame.minY

            // If position didn't change, we're at top
            if abs(beforeY - afterY) < 1 {
                break
            }
        }

        return self
    }

    /// Scroll to bottom of scroll view
    /// - Parameter maxScrolls: Maximum number of scroll attempts
    @discardableResult
    func scrollToBottom(maxScrolls: Int = 10) -> Self {
        guard exists else { return self }

        for _ in 0..<maxScrolls {
            let beforeY = frame.maxY
            swipeUp()
            Thread.sleep(forTimeInterval: 0.2)
            let afterY = frame.maxY

            // If position didn't change, we're at bottom
            if abs(beforeY - afterY) < 1 {
                break
            }
        }

        return self
    }

    /// Scroll to find element matching condition
    /// - Parameters:
    ///   - direction: Initial scroll direction
    ///   - maxScrolls: Maximum scrolls per direction
    ///   - condition: Condition to check
    /// - Returns: true if element found
    @discardableResult
    func scrollToFind(
        direction: ScrollDirection = .down,
        maxScrolls: Int = 10,
        condition: () -> Bool
    ) -> Bool {
        // Try current direction
        for _ in 0..<maxScrolls {
            if condition() {
                return true
            }

            switch direction {
            case .up:
                swipeDown()
            case .down:
                swipeUp()
            case .left:
                swipeRight()
            case .right:
                swipeLeft()
            }

            Thread.sleep(forTimeInterval: 0.3)
        }

        // Try opposite direction
        let oppositeDirection = direction.opposite

        for _ in 0..<maxScrolls {
            if condition() {
                return true
            }

            switch oppositeDirection {
            case .up:
                swipeDown()
            case .down:
                swipeUp()
            case .left:
                swipeRight()
            case .right:
                swipeLeft()
            }

            Thread.sleep(forTimeInterval: 0.3)
        }

        return condition()
    }

    // MARK: - Coordinate-Based Scroll

    /// Perform scroll using normalized coordinates
    /// - Parameters:
    ///   - start: Start coordinate (normalized 0-1)
    ///   - end: End coordinate (normalized 0-1)
    ///   - duration: Scroll duration
    func scroll(from start: CGVector, to end: CGVector, duration: TimeInterval = 0.5) {
        let startCoord = coordinate(withNormalizedOffset: start)
        let endCoord = coordinate(withNormalizedOffset: end)
        startCoord.press(forDuration: 0.05, thenDragTo: endCoord, withVelocity: .default, thenHoldForDuration: 0.1)
    }

    /// Scroll down by a percentage of element height
    /// - Parameter percentage: Percentage of height to scroll (0-1)
    func scrollDown(by percentage: CGFloat = 0.7) {
        let start = CGVector(dx: 0.5, dy: 0.8)
        let end = CGVector(dx: 0.5, dy: 0.8 - percentage)
        scroll(from: start, to: end)
    }

    /// Scroll up by a percentage of element height
    /// - Parameter percentage: Percentage of height to scroll (0-1)
    func scrollUp(by percentage: CGFloat = 0.7) {
        let start = CGVector(dx: 0.5, dy: 0.2)
        let end = CGVector(dx: 0.5, dy: 0.2 + percentage)
        scroll(from: start, to: end)
    }
}

// MARK: - Scroll Direction

/// Scroll direction enumeration
enum ScrollDirection {
    case up
    case down
    case left
    case right

    /// Get opposite direction
    var opposite: ScrollDirection {
        switch self {
        case .up: return .down
        case .down: return .up
        case .left: return .right
        case .right: return .left
        }
    }
}
