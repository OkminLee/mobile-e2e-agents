//
//  XCUIElement+Wait.swift
//  {{PROJECT_NAME}}UITests
//
//  XCUIElement extensions for waiting and safe interactions
//  Generated by mobile-e2e-agents
//

import XCTest

extension XCUIElement {

    // MARK: - Wait Methods

    /// Wait for element to become hittable (exists and is tappable)
    /// - Parameter timeout: Maximum time to wait
    /// - Returns: true if element became hittable within timeout
    @discardableResult
    func waitToBeHittable(timeout: TimeInterval = Timeout.medium) -> Bool {
        let predicate = NSPredicate(format: "exists == true AND isHittable == true")
        let expectation = XCTNSPredicateExpectation(predicate: predicate, object: self)
        let result = XCTWaiter.wait(for: [expectation], timeout: timeout)
        return result == .completed
    }

    /// Wait for element to exist and be hittable
    /// - Parameter timeout: Maximum time to wait
    /// - Returns: true if element exists and is hittable
    @discardableResult
    func waitToExistAndBeHittable(timeout: TimeInterval = Timeout.medium) -> Bool {
        guard waitForExistence(timeout: timeout) else {
            return false
        }
        return waitToBeHittable(timeout: timeout / 2)
    }

    /// Wait for element to disappear
    /// - Parameter timeout: Maximum time to wait
    /// - Returns: true if element disappeared within timeout
    @discardableResult
    func waitToDisappear(timeout: TimeInterval = Timeout.medium) -> Bool {
        let predicate = NSPredicate(format: "exists == false")
        let expectation = XCTNSPredicateExpectation(predicate: predicate, object: self)
        let result = XCTWaiter.wait(for: [expectation], timeout: timeout)
        return result == .completed
    }

    /// Wait for element value to change to expected value
    /// - Parameters:
    ///   - value: Expected value
    ///   - timeout: Maximum time to wait
    /// - Returns: true if value changed to expected within timeout
    @discardableResult
    func waitForValue(_ value: String, timeout: TimeInterval = Timeout.medium) -> Bool {
        let predicate = NSPredicate(format: "value == %@", value)
        let expectation = XCTNSPredicateExpectation(predicate: predicate, object: self)
        let result = XCTWaiter.wait(for: [expectation], timeout: timeout)
        return result == .completed
    }

    /// Wait for element label to contain text
    /// - Parameters:
    ///   - text: Text to search for
    ///   - timeout: Maximum time to wait
    /// - Returns: true if label contains text within timeout
    @discardableResult
    func waitForLabel(containing text: String, timeout: TimeInterval = Timeout.medium) -> Bool {
        let predicate = NSPredicate(format: "label CONTAINS[c] %@", text)
        let expectation = XCTNSPredicateExpectation(predicate: predicate, object: self)
        let result = XCTWaiter.wait(for: [expectation], timeout: timeout)
        return result == .completed
    }

    // MARK: - Safe Interactions

    /// Safely tap element after verifying it's hittable
    /// - Parameter timeout: Maximum time to wait for hittable state
    /// - Returns: true if tap was successful
    @discardableResult
    func safeTap(timeout: TimeInterval = Timeout.medium) -> Bool {
        guard waitToBeHittable(timeout: timeout) else {
            XCTFail("Element not hittable: \(self)")
            return false
        }
        tap()
        return true
    }

    /// Safely type text after verifying element is hittable
    /// - Parameters:
    ///   - text: Text to type
    ///   - timeout: Maximum time to wait
    /// - Returns: true if typing was successful
    @discardableResult
    func safeTypeText(_ text: String, timeout: TimeInterval = Timeout.medium) -> Bool {
        guard waitToBeHittable(timeout: timeout) else {
            XCTFail("Element not hittable for typing: \(self)")
            return false
        }
        tap()
        typeText(text)
        return true
    }

    /// Safely clear and type text
    /// - Parameters:
    ///   - text: Text to type
    ///   - timeout: Maximum time to wait
    /// - Returns: true if successful
    @discardableResult
    func safeClearAndTypeText(_ text: String, timeout: TimeInterval = Timeout.medium) -> Bool {
        guard waitToBeHittable(timeout: timeout) else {
            XCTFail("Element not hittable for clearing: \(self)")
            return false
        }

        // Select all and delete
        tap()
        if let currentValue = value as? String, !currentValue.isEmpty {
            tap()
            let selectAll = XCUIApplication().menuItems["Select All"]
            if selectAll.waitForExistence(timeout: 1) {
                selectAll.tap()
                typeText(XCUIKeyboardKey.delete.rawValue)
            }
        }

        typeText(text)
        return true
    }

    // MARK: - State Checks

    /// Check if element is currently hidden
    var isHidden: Bool {
        !exists || !isHittable
    }

    /// Check if switch/toggle is currently on
    var isOn: Bool {
        (value as? String) == "1"
    }

    /// Check if switch/toggle is currently off
    var isOff: Bool {
        (value as? String) == "0"
    }
}
